<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8"/>
    <title>Combined Chinese Q&A Recorder & Text Reader</title>
    <script src="https://cdn.jsdelivr.net/npm/hanzi-writer@3.5/dist/hanzi-writer.min.js"></script>
    <style>
        /* --- General Layout --- */
        html, body {
            height: 100%;
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            overflow: hidden;
        }
        #main-container {
            display: flex;
            height: 100vh;
        }
        .panel {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            overflow: auto;
            height: 100vh;
        }
        #left-panel {
            background-color: #f8f9fa;
            border-right: 2px solid #dee2e6;
        }
        #right-panel {
            background-color: #ffffff;
            resize: horizontal;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        h1, h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            margin: 5px 5px 5px 0;
            cursor: pointer;
            border-radius: 5px;
            border: 1px solid #ccc;
            background-color: #e9ecef;
        }
        button:hover {
            background-color: #d8dde2;
        }
        /* --- Styles from Q&A Recorder (Left Panel) --- */
        .question-block {
            background: #fff;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .question-text {
            font-size: 1.1em;
            margin-bottom: 10px;
            padding: 6px;
            border: 1px dashed transparent;
        }
        .question-text[contenteditable="true"]:focus {
            border: 1px dashed #888;
            background-color: #f0f8ff;
            outline: none;
        }
        .answer {
            margin-top: 10px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            min-height: 30px;
            border: 1px solid #ddd;
            line-height: 1.6;
        }
        .audio-status {
            display: inline-block;
            margin-left: 6px;
            color: green;
            font-weight: bold;
            visibility: hidden;
        }
        .audio-status.visible {
            visibility: visible;
        }
        input[type="file"] {
            margin: 10px 0;
        }
        textarea {
            width: 100%;
            margin-top: 10px;
            padding: 8px;
            box-sizing: border-box;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        .model-answer {
             background-color: #e6ffed;
        }
        .score-display {
            font-weight: bold;
            color: #0056b3;
            margin-left: 10px;
        }
        /* --- Styles from TextReader (Right Panel) --- */
        #text-area {
            width: 100%;
            border: 1px solid #ccc;
            padding: 10px;
            font-size: 18px;
            overflow: auto;
            box-sizing: border-box;
            flex-grow: 1;
        }
        #controls-right {
            padding-top: 10px;
        }
        #tts-controls {
            margin-bottom: 10px;
            background-color: #f8f8f8;
            padding: 10px;
            border-radius: 5px;
        }
        #tts-controls label {
            margin-right: 10px;
        }
        #speed-slider {
            vertical-align: middle;
        }
        #speed-value {
            font-weight: bold;
            color: #333;
        }
        /* CSS cho highlight */
        .reading-highlight {
            background-color: rgb(173, 216, 230); /* M√†u xanh nh·∫°t */
        }

        /* --- CSS CHO T√çNH NƒÇNG STROKE ORDER --- */
        #stroke-order-modal {
            display: none; /* ·∫®n theo m·∫∑c ƒë·ªãnh */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
        }
        #stroke-order-content {
            background-color: #fff;
            padding: 20px 40px 40px 40px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        #stroke-order-container {
            display: flex;
            flex-wrap: wrap; /* Cho ph√©p xu·ªëng d√≤ng n·∫øu kh√¥ng ƒë·ªß ch·ªó */
            justify-content: center;
            align-items: flex-start; /* CƒÉn l·ªÅ tr√™n */
            gap: 20px; /* Kho·∫£ng c√°ch gi·ªØa c√°c √¥ */
            margin-bottom: 20px;
        }
        /* Style cho kh·ªëi bao g·ªìm ch·ªØ H√°n v√† th√¥ng tin b·ªô th·ªß */
        .character-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .char-writer-box {
            width: 150px;
            height: 150px;
            cursor: crosshair;
            border: 1px solid #eee;
        }
        /* Style cho ph·∫ßn th√¥ng tin b·ªô th·ªß */
        .radical-info {
            width: 150px;
            margin-top: 8px;
            font-size: 13px;
            color: #444;
            text-align: left;
            padding-left: 5px;
            line-height: 1.5;
        }
        #stroke-order-buttons button {
            margin: 0 10px;
            padding: 10px 20px;
        }
        #stroke-order-close-btn {
            background-color: #6c757d;
            color: white;
            border: none;
        }
        #stroke-order-close-btn:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>

<div id="main-container">
    <div id="left-panel" class="panel">
        <h1>Questions and Answers ‚Äì Voice Recording (Chinese)</h1>
        <h2>üìÇ Import questions from file:</h2>
        <input accept=".docx,.txt" id="file-input" type="file"/>
        <h2>üì• Import Q&A from ZIP:</h2>
        <input type="file" id="zip-input" accept=".zip">
        <div id="questions-container">
            </div>
        <button onclick="addNewQuestion()">‚ûï Add New Question</button>
        <button onclick="exportData()">üì§ Export Data to ZIP</button>
        <button onclick="createNewSession()">‚ûï Create New Session</button>
    </div>

    <div id="right-panel" class="panel">
        <h1>Paste Chinese text here to listen with Xiaoxiao's voice</h1>
        <div id="text-area" contenteditable="true">
            Paste text here...
        </div>
        <div id="controls-right">
             <div id="tts-controls">
                <label for="speed-slider">T·ªëc ƒë·ªô ƒë·ªçc:</label>
                <input type="range" id="speed-slider" min="0.5" max="2" value="1" step="0.1">
                <span id="speed-value">1.0x</span>
            </div>
            <button id="read-all">üîä Read All Text</button>
            <button id="read-current-sentence">üîä Read Current Sentence</button>
            <button id="highlight-button">üé® Highlight</button>
            <button id="remove-highlight-button">üóëÔ∏è X√≥a Highlight</button>
        </div>
    </div>
</div>

<div id="stroke-order-modal">
    <div id="stroke-order-content">
        <h3 id="stroke-order-title">Luy·ªán vi·∫øt ch·ªØ H√°n</h3>
        <div id="stroke-order-container"></div>
        <div id="stroke-order-buttons">
             <button id="stroke-order-animate-all-btn">Xem l·∫°i t·∫•t c·∫£</button>
             <button id="stroke-order-close-btn">ƒê√≥ng</button>
        </div>
    </div>
</div>

<script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

<script>
    // =================================================================
    // =========== C√°c ph·∫ßn JavaScript kh√°c (gi·ªØ nguy√™n) ============
    // =================================================================
    let chineseTTSVoice = null;
    let recognition;
    let mediaRecorder;
    let audioChunks = [];
    const audioBlobs = {};

    let currentAnswerIndex = null;
    let currentAudioIndex = null;
    let questionCount = 0;

    let currentPlaybackRate = 1.0;
    let isReading = false;
    let currentUtterance = null;
    const highlightColors = ["#ffff99", "#99ccff", "#ffcc99", "#ffcccb", "#ffb6c1", "#98fb98", "#dda0dd", "#c19a6b"];
    let currentColorIndex = 0;

    function initializeVoices() {
        const voices = speechSynthesis.getVoices();
        chineseTTSVoice = voices.find(v => v.name === "Microsoft Xiaoxiao Online (Natural) - Chinese (Mainland)") || voices.find(v => v.name.includes("Xiaoxiao") && v.lang === "zh-CN");
        if (chineseTTSVoice) {
            console.log("Successfully found Chinese voice:", chineseTTSVoice.name);
        } else {
            console.warn("Xiaoxiao voice not found. The browser's default Chinese voice will be used.");
        }
    }

    if (!('webkitSpeechRecognition' in window)) {
        alert('Speech recognition not supported in this browser.');
    } else {
        recognition = new webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = false;
        recognition.lang = 'zh-CN';
        recognition.onresult = function (event) {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; ++i) {
                if (event.results[i].isFinal) {
                    transcript += event.results[i][0].transcript;
                }
            }
            if (currentAnswerIndex !== null && transcript) {
                const answerBox = document.getElementById(`answer-${currentAnswerIndex}`);
                answerBox.innerHTML = answerBox.textContent + (answerBox.textContent.trim() ? '. ' : '') + transcript;
            }
        };
        recognition.onerror = function (event) {
            console.error('Speech recognition error:', event.error);
        };
    }

    function startRecognition(index) {
        currentAnswerIndex = index;
        if (recognition) recognition.start();
        startAudioRecording(index);
    }

    function stopRecognition() {
        if (recognition) recognition.stop();
        stopAudioRecording();
    }

    async function startAudioRecording(index) {
        currentAudioIndex = index;
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(audioChunks, { type: 'audio/webm' });
                audioBlobs[currentAudioIndex] = blob;
                const audioURL = URL.createObjectURL(blob);
                const audioElement = document.getElementById(`audio-${currentAudioIndex}`);
                audioElement.src = audioURL;
                audioElement.style.display = 'block';
                showAudioStatus(currentAudioIndex);
            };
            mediaRecorder.start();
        } catch (err) {
            console.error("Error starting audio recording:", err);
            alert("Could not start audio recording. Please grant microphone permissions.");
        }
    }

    function stopAudioRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
        }
    }

    function playAudio(index) {
        const audio = document.getElementById(`audio-${index}`);
        if(audio.src) {
           audio.play();
        } else {
            alert("No audio recorded for this question yet.");
        }
    }

    function speak(text, textOffset = 0) {
        if (isReading) {
            speechSynthesis.cancel();
        }
        removeHighlight();
        const cleanedText = text.replace(/[\u2500-\u25FF\u2B00-\u2BFF]/g, '')
                                .replace(/Ki·ªÉm tra/g, '')
                                .replace(/G√µ l·∫°i c√¢u n√†y/g, '')
                                .replace(/X√≥a\/L√†m l·∫°i/g, '')
                                .replace(/\s+/g, ' ')
                                .trim();
        if (!cleanedText) {
            isReading = false;
            return;
        }
        currentUtterance = new SpeechSynthesisUtterance(cleanedText);
        currentUtterance.lang = 'zh-CN';
        if (chineseTTSVoice) currentUtterance.voice = chineseTTSVoice;
        currentUtterance.rate = currentPlaybackRate;
        currentUtterance.onboundary = function(event) {
            if (event.name === 'word') {
                const word = currentUtterance.text.substring(event.charIndex, event.charIndex + event.charLength);
                applyHighlight(word, textOffset + event.charIndex);
            }
        };
        currentUtterance.onstart = function() {
            isReading = true;
        };
        currentUtterance.onend = function() {
            isReading = false;
            removeHighlight();
            currentUtterance = null;
        };
        speechSynthesis.speak(currentUtterance);
    }

    function speakQuestion(index) {
        const text = document.querySelector(`.question-block[data-index="${index}"] .question-text`).textContent;
        speak(text);
    }

    function addNewQuestion() {
        const container = document.getElementById('questions-container');
        const index = questionCount;
        const questionDiv = document.createElement('div');
        questionDiv.className = 'question-block';
        questionDiv.setAttribute('data-index', index);
        questionDiv.innerHTML = `
            <div class="question-text" contenteditable="true">${index + 1}. </div>
            <button onclick="speakQuestion(${index})">üîà Read</button>
            <button onclick="startRecognition(${index})">üé§ Start Recording</button>
            <button onclick="stopRecognition()">üõë Stop</button>
            <button onclick="playAudio(${index})">‚ñ∂Ô∏è Play</button>
            <span class="audio-status" id="audio-status-${index}">üîä</span>
            <div class="answer" id="answer-${index}"></div>
            <textarea placeholder="‚úçÔ∏è Type your answer here..." style="width: 100%;"></textarea>
            <textarea class="model-answer" placeholder="‚úçÔ∏è Nh·∫≠p c√¢u tr·∫£ l·ªùi m·∫´u ·ªü ƒë√¢y..."></textarea>
            <button onclick="scoreAnswer(${index})">‚≠ê Ch·∫•m ƒëi·ªÉm</button>
            <span class="score-display" id="score-display-${index}"></span>
            <audio id="audio-${index}" controls style="display: none;"></audio>
        `;
        container.appendChild(questionDiv);
        questionCount++;
    }

    function showAudioStatus(index) {
        const statusIcon = document.getElementById(`audio-status-${index}`);
        if (statusIcon) statusIcon.classList.add("visible");
    }

    function createNewSession() {
        window.open(window.location.pathname + `?id=${Date.now()}_${Math.floor(Math.random() * 100000)}`, '_blank');
    }

    document.getElementById("file-input").addEventListener("change", function (event) {
        const file = event.target.files[0];
        if (!file) return;
        const processQuestions = (questions) => {
            document.getElementById("questions-container").innerHTML = '';
            questionCount = 0;
            questions.forEach(qText => {
                if (!qText.trim()) return;
                addNewQuestion();
                const newBlock = document.querySelector(`.question-block[data-index="${questionCount-1}"]`);
                newBlock.querySelector(".question-text").textContent = qText.trim();
            });
        };
        if (file.name.endsWith(".txt")) {
            const reader = new FileReader();
            reader.onload = () => processQuestions(reader.result.split(/\r?\n/).filter(Boolean));
            reader.readAsText(file);
        } else if (file.name.endsWith(".docx")) {
            const reader = new FileReader();
            reader.onload = (e) => {
                mammoth.extractRawText({ arrayBuffer: e.target.result })
                    .then(result => processQuestions(result.value.split("\n").filter(Boolean)));
            };
            reader.readAsArrayBuffer(file);
        }
    });

    function exportData() {
        const zip = new JSZip();
        const blocks = document.querySelectorAll(".question-block");
        let qaContent = "";
        const modelAnswerToken = "[model_answer]";
        const answerToken = "Answer:";
        blocks.forEach((block) => {
            const index = block.getAttribute('data-index');
            const question = block.querySelector(".question-text").textContent.trim();
            const modelAnswer = block.querySelector(".model-answer").value.trim();
            const voiceAnswer = block.querySelector(".answer").textContent.trim();
            const typedAnswer = block.querySelector("textarea:not(.model-answer)").value.trim();
            const finalAnswer = typedAnswer || voiceAnswer;
            qaContent += `${question}\n`;
            if (modelAnswer) {
                qaContent += `${modelAnswerToken}${modelAnswer}\n`;
            }
            qaContent += `${answerToken} ${finalAnswer}\n\n`;
            if (audioBlobs[index]) zip.file(`audio_${parseInt(index) + 1}.webm`, audioBlobs[index]);
        });
        zip.file("qa_export.txt", qaContent);
        const rightPanelHtml = document.getElementById('text-area').innerHTML;
        if (rightPanelHtml && rightPanelHtml !== 'Paste text here...') {
            zip.file("reading_text.html", rightPanelHtml);
        }
        zip.generateAsync({ type: "blob" }).then(blob => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `export_session_${Date.now()}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    }

    document.getElementById('zip-input').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (!file) return;
        const zip = new JSZip();
        zip.loadAsync(file).then(async function (zipContent) {
            const qaFile = zipContent.file("qa_export.txt");
            if (qaFile) {
                const qaText = await qaFile.async("string");
                const entries = qaText.split('\n\n').filter(Boolean);
                document.getElementById("questions-container").innerHTML = '';
                questionCount = 0;
                Object.keys(audioBlobs).forEach(key => delete audioBlobs[key]);
                const modelAnswerToken = "[model_answer]";
                const answerToken = "Answer: ";
                for (const entry of entries) {
                    const lines = entry.split('\n').filter(Boolean);
                    if (lines.length === 0) continue;
                    const questionLine = lines[0];
                    let modelAnswerLine = '';
                    let answerLine = '';
                    lines.forEach(line => {
                        if (line.startsWith(modelAnswerToken)) {
                            modelAnswerLine = line.substring(modelAnswerToken.length);
                        } else if (line.startsWith(answerToken)) {
                            answerLine = line.substring(answerToken.length);
                        }
                    });
                    addNewQuestion();
                    const index = questionCount - 1;
                    const qBlock = document.querySelector(`.question-block[data-index="${index}"]`);
                    qBlock.querySelector(".question-text").textContent = questionLine.trim();
                    if(modelAnswerLine) qBlock.querySelector(".model-answer").value = modelAnswerLine.trim();
                    const answerDiv = qBlock.querySelector(".answer");
                    const typedAnswerTextarea = qBlock.querySelector("textarea:not(.model-answer)");
                    if (answerLine) {
                         typedAnswerTextarea.value = answerLine.trim();
                         answerDiv.textContent = '';
                    }
                    const audioFile = zipContent.file(`audio_${index + 1}.webm`);
                    if (audioFile) {
                        const blob = await audioFile.async("blob");
                        audioBlobs[index] = blob;
                        const audioURL = URL.createObjectURL(blob);
                        const audioElement = qBlock.querySelector("audio");
                        audioElement.src = audioURL;
                        audioElement.style.display = "block";
                        showAudioStatus(index);
                    }
                }
            }
            const readingTextHtmlFile = zipContent.file("reading_text.html");
            if (readingTextHtmlFile) {
                document.getElementById('text-area').innerHTML = await readingTextHtmlFile.async("string");
            }
        });
    });

    function levenshteinDistance(s1, s2) {
        const cleanS1 = s1.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, '');
        const cleanS2 = s2.toLowerCase().replace(/[^\p{L}\p{N}\s]/gu, '');
        const costs = [];
        for (let i = 0; i <= cleanS1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= cleanS2.length; j++) {
                if (i == 0) { costs[j] = j; }
                else {
                    if (j > 0) {
                        let newValue = costs[j - 1];
                        if (cleanS1.charAt(i - 1) != cleanS2.charAt(j - 1)) {
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        }
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0) costs[cleanS2.length] = lastValue;
        }
        return costs[cleanS2.length];
    }

    function computeLCS(words1, words2) {
        const m = words1.length;
        const n = words2.length;
        const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
        for (let i = 1; i <= m; i++) {
            for (let j = 1; j <= n; j++) {
                const cleanWord1 = words1[i - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
                const cleanWord2 = words2[j - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
                if (cleanWord1 === cleanWord2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp;
    }

    function generateDiff(userWords, modelWords, dp) {
        let i = userWords.length, j = modelWords.length;
        const diff = [];
        while (i > 0 && j > 0) {
            const cleanUserWord = userWords[i - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
            const cleanModelWord = modelWords[j - 1].toLowerCase().replace(/[^\p{L}\p{N}]/gu, '');
            if (cleanUserWord === cleanModelWord) {
                diff.unshift({ type: 'correct', text: userWords[i - 1] });
                i--; j--;
            } else if (dp[i - 1][j] >= dp[i][j - 1]) {
                diff.unshift({ type: 'incorrect', text: userWords[i - 1] });
                i--;
            } else {
                j--;
            }
        }
        while (i > 0) {
            diff.unshift({ type: 'incorrect', text: userWords[i - 1] });
            i--;
        }
        return diff;
    }

    function scoreAnswer(index) {
        const modelAnswer = document.querySelector(`.question-block[data-index="${index}"] .model-answer`).value.trim();
        const userAnswerDiv = document.getElementById(`answer-${index}`);
        const typedAnswer = document.querySelector(`.question-block[data-index="${index}"] textarea:not(.model-answer)`).value.trim();
        let userAnswer = typedAnswer || userAnswerDiv.textContent.trim();
        if (typedAnswer) { userAnswerDiv.textContent = typedAnswer; }
        const scoreDisplay = document.getElementById(`score-display-${index}`);
        if (!modelAnswer) { alert("Vui l√≤ng nh·∫≠p c√¢u tr·∫£ l·ªùi m·∫´u ƒë·ªÉ ch·∫•m ƒëi·ªÉm."); return; }
        if (!userAnswer) { alert("Vui l√≤ng ghi √¢m ho·∫∑c nh·∫≠p c√¢u tr·∫£ l·ªùi tr∆∞·ªõc khi ch·∫•m ƒëi·ªÉm."); return; }
        const distance = levenshteinDistance(modelAnswer, userAnswer);
        const longerLength = Math.max(modelAnswer.length, userAnswer.length);
        if (longerLength === 0) { scoreDisplay.textContent = "Score: 100%"; }
        else {
             const similarity = (1 - (distance / longerLength)) * 100;
             scoreDisplay.textContent = `Score: ${Math.round(similarity)}%`;
        }
        const userWords = userAnswer.split(/\s+/).filter(Boolean);
        const modelWords = modelAnswer.split(/\s+/).filter(Boolean);
        const dp = computeLCS(userWords, modelWords);
        const diff = generateDiff(userWords, modelWords, dp);
        const highlightedHtml = diff.map(part => {
            const color = part.type === 'correct' ? 'green' : 'red';
            const escapedText = part.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
            return `<span style="color: ${color};">${escapedText}</span>`;
        }).join(' ');
        userAnswerDiv.innerHTML = highlightedHtml || '';
    }

    const textNodeFilter = {
        acceptNode: function(node) {
            if (node.parentNode && (node.parentNode.classList.contains('script-checker-input') ||
                                   node.parentNode.classList.contains('script-checker-button') ||
                                   node.parentNode.classList.contains('script-checker-controls') ||
                                   node.parentNode.classList.contains('masked-text-display') ||
                                   node.parentNode.classList.contains('script-checker-clear-button'))) {
                return NodeFilter.FILTER_REJECT;
            }
            if (!node.nodeValue || node.nodeValue.trim() === '') {
                return NodeFilter.FILTER_REJECT;
            }
            return NodeFilter.FILTER_ACCEPT;
        }
    };

    function getTextContentOfTextArea(textAreaElement) {
        let textContent = '';
        const walker = document.createTreeWalker(textAreaElement, NodeFilter.SHOW_TEXT, textNodeFilter, false);
        let node;
        while (node = walker.nextNode()) {
            textContent += node.nodeValue;
        }
        return textContent;
    }

    function removeHighlight() {
        const textArea = document.getElementById('text-area');
        const highlightedSpans = textArea.querySelectorAll('.reading-highlight');
        highlightedSpans.forEach(span => {
            span.parentNode.replaceChild(document.createTextNode(span.textContent), span);
        });
        textArea.normalize();
    }


    function applyHighlight(wordText, charIndexInCleanedText) {
        removeHighlight();
        const textArea = document.getElementById('text-area');
        const fullCleanedText = getTextContentOfTextArea(textArea);
        const startIndex = charIndexInCleanedText;
        const endIndex = charIndexInCleanedText + wordText.length;
        const range = document.createRange();
        let currentOffset = 0;
        let startNode = null;
        let endNode = null;
        let startNodeOffset = 0;
        let endNodeOffset = 0;
        const walker = document.createTreeWalker(textArea, NodeFilter.SHOW_TEXT, textNodeFilter, false);
        let node;
        while ((node = walker.nextNode())) {
            const nodeValue = node.nodeValue;
            if (currentOffset <= startIndex && (currentOffset + nodeValue.length) > startIndex && startNode === null) {
                startNode = node;
                startNodeOffset = startIndex - currentOffset;
            }
            if (currentOffset <= endIndex && (currentOffset + nodeValue.length) >= endIndex) {
                endNode = node;
                endNodeOffset = endIndex - currentOffset;
                break;
            }
            currentOffset += nodeValue.length;
        }
        if (startNode && endNode) {
            try {
                range.setStart(startNode, startNodeOffset);
                range.setEnd(endNode, endNodeOffset);
                const span = document.createElement('span');
                span.className = 'reading-highlight';
                range.surroundContents(span);
            } catch (e) {
                console.error("Error surrounding contents for highlight:", e);
                removeHighlight();
            }
        }
    }

    document.getElementById("text-area").addEventListener("mouseup", function () {
        setTimeout(() => {
            const selection = window.getSelection();
            if (selection.isCollapsed) {
                return;
            }
            let selectedText = selection.toString().trim();
            if (selectedText) {
                selectedText = selectedText.replace(/Ki·ªÉm tra/g, '').replace(/G√µ l·∫°i c√¢u n√†y/g, '').replace(/X√≥a\/L√†m l·∫°i/g, '').trim();
                speak(selectedText);
            }
        }, 100);
    });

    document.getElementById("read-all").addEventListener("click", function () {
        const textArea = document.getElementById("text-area");
        let fullTextToSpeak = getTextContentOfTextArea(textArea);
        if (fullTextToSpeak && fullTextToSpeak.trim() !== 'Paste text here...') {
            speak(fullTextToSpeak);
        } else {
            alert("There is no text to read!");
        }
    });

    document.getElementById("read-current-sentence").addEventListener("click", function() {
        const textArea = document.getElementById('text-area');
        const selection = window.getSelection();
        if (selection.rangeCount === 0) {
            alert("Vui l√≤ng ƒë·∫∑t con tr·ªè chu·ªôt v√†o v·ªã tr√≠ mu·ªën ƒë·ªçc ho·∫∑c ch·ªçn m·ªôt ƒëo·∫°n vƒÉn b·∫£n.");
            return;
        }
        const range = selection.getRangeAt(0);
        const preCursorRange = document.createRange();
        preCursorRange.selectNodeContents(textArea);
        preCursorRange.setEnd(range.startContainer, range.startOffset);
        const tempDiv = document.createElement('div');
        tempDiv.appendChild(preCursorRange.cloneContents());
        const offsetInFilteredText = getTextContentOfTextArea(tempDiv).length;
        const fullTextNodes = getTextContentOfTextArea(textArea);
        let sentenceStart = offsetInFilteredText;
        while (sentenceStart > 0) {
            const char = fullTextNodes[sentenceStart - 1];
            if (char === '.' || char === '?' || char === '!' || char === '\n') {
                break;
            }
            sentenceStart--;
        }
        while (sentenceStart < fullTextNodes.length && (fullTextNodes[sentenceStart] === ' ' || fullTextNodes[sentenceStart] === '\n' || fullTextNodes[sentenceStart].match(/[.,?!]/))) {
            sentenceStart++;
        }
        let sentenceEnd = offsetInFilteredText;
        while (sentenceEnd < fullTextNodes.length) {
            const char = fullTextNodes[sentenceEnd];
            if (char === '.' || char === '?' || char === '!' || char === '\n') {
                sentenceEnd++;
                break;
            }
            sentenceEnd++;
        }
        let sentenceToRead = fullTextNodes.substring(sentenceStart, sentenceEnd).trim();
        if (sentenceToRead) {
            speak(sentenceToRead, sentenceStart);
        } else {
            alert("Kh√¥ng t√¨m th·∫•y c√¢u ƒë·ªÉ ƒë·ªçc t·∫°i v·ªã tr√≠ con tr·ªè.");
        }
    });


    document.getElementById("highlight-button").addEventListener("click", function () {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) return;
        const color = highlightColors[currentColorIndex];
        document.execCommand('backColor', false, color);
        currentColorIndex = (currentColorIndex + 1) % highlightColors.length;
    });

    document.getElementById("remove-highlight-button").addEventListener("click", function () {
        const selection = window.getSelection();
        if (!selection.rangeCount || selection.isCollapsed) return;
        document.execCommand('backColor', false, 'transparent');
    });

    const speedSlider = document.getElementById('speed-slider');
    const speedValue = document.getElementById('speed-value');
    speedSlider.addEventListener('input', function() {
        currentPlaybackRate = parseFloat(this.value);
        speedValue.textContent = `${currentPlaybackRate.toFixed(1)}x`;
    });

    // =================================================================
    // =========== LOGIC M·ªöI CHO T√çNH NƒÇNG STROKE ORDER QUIZ ============
    // =================================================================
    
    // *** PHI√äN B·∫¢N OFFLINE HO√ÄN TO√ÄN V·ªöI D·ªÆ LI·ªÜU L·ªöN ***
    const localRadicalData = {
        'ÁöÑ':[{radical:'ÁôΩ',name:'B·∫°ch',meaning:'tr·∫Øng'},{radical:'Âã∫',name:'Th∆∞·ª£c',meaning:'c√°i th√¨a'}],'‰∏Ä':[{radical:'‰∏Ä',name:'Nh·∫•t',meaning:'s·ªë m·ªôt'}],'ÊòØ':[{radical:'Êó•',name:'Nh·∫≠t',meaning:'m·∫∑t tr·ªùi'},{radical:'Áñã',name:'Th·∫•t',meaning:'ƒë∆°n v·ªã ƒëo'}],'‰∏ç':[{radical:'‰∏ç',name:'B·∫•t',meaning:'kh√¥ng'}],'‰∫Ü':[{radical:'‰∫Ü',name:'Li·ªÖu',meaning:'xong'}],'Âú®':[{radical:'Âúü',name:'Th·ªï',meaning:'ƒë·∫•t'}],'‰∫∫':[{radical:'‰∫∫',name:'Nh√¢n',meaning:'ng∆∞·ªùi'}],'Êúâ':[{radical:'Êúà',name:'Nguy·ªát',meaning:'m·∫∑t trƒÉng'}],'Êàë':[{radical:'Êâã',name:'Th·ªß',meaning:'tay'},{radical:'Êàà',name:'Qua',meaning:'c√°i m√°c'}],'‰ªñ':[{radical:'‰∫ª',name:'Nh√¢n ƒë·ª©ng',meaning:'ng∆∞·ªùi'},{radical:'‰πü',name:'D√£',meaning:'c≈©ng'}],'Ëøô':[{radical:'Êñá',name:'VƒÉn',meaning:'vƒÉn v·∫ª'}],'‰∏™':[{radical:'‰∫∫',name:'Nh√¢n',meaning:'ng∆∞·ªùi'}],'‰ª¨':[{radical:'‰∫ª',name:'Nh√¢n ƒë·ª©ng',meaning:'ng∆∞·ªùi'},{radical:'Èó®',name:'M√¥n',meaning:'c·ª≠a'}],'‰∏≠':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Êù•':[{radical:'Êú®',name:'M·ªôc',meaning:'c√¢y'}],'‰∏ä':[{radical:'Âçú',name:'B·ªëc',meaning:'xem b√≥i'}],'Â§ß':[{radical:'Â§ß',name:'ƒê·∫°i',meaning:'to l·ªõn'}],'‰∏∫':[{radical:'‰∏∂',name:'Ch·ªß',meaning:'ch·∫•m'}],'Âíå':[{radical:'Á¶æ',name:'H√≤a',meaning:'l√∫a'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'ÂõΩ':[{radical:'Âõó',name:'Vi',meaning:'v√¢y quanh'},{radical:'Áéâ',name:'Ng·ªçc',meaning:'ng·ªçc'}],'Âú∞':[{radical:'Âúü',name:'Th·ªï',meaning:'ƒë·∫•t'},{radical:'‰πü',name:'D√£',meaning:'c≈©ng'}],'Âà∞':[{radical:'Ëá≥',name:'Ch√≠',meaning:'ƒë·∫øn'},{radical:'ÂàÇ',name:'ƒêao',meaning:'con dao'}],'‰ª•':[{radical:'‰∫∫',name:'Nh√¢n',meaning:'ng∆∞·ªùi'}],'ËØ¥':[{radical:'ËÆ†',name:'Ng√¥n',meaning:'l·ªùi n√≥i'},{radical:'ÂÖë',name:'ƒêo√†i',meaning:'ƒëo√°i'}],'Êó∂':[{radical:'Êó•',name:'Nh·∫≠t',meaning:'m·∫∑t tr·ªùi'},{radical:'ÂØ∏',name:'Th·ªën',meaning:'t·∫•c'}],'Ë¶Å':[{radical:'Ë¶Ä',name:'T√¢y',meaning:'ph√≠a t√¢y'},{radical:'Â•≥',name:'N·ªØ',meaning:'ph·ª• n·ªØ'}],'Â∞±':[{radical:'‰∫¨',name:'Kinh',meaning:'kinh ƒë√¥'},{radical:'Â∞§',name:'V∆∞u',meaning:'ƒë·∫∑c bi·ªát'}],'Âá∫':[{radical:'Â±±',name:'S∆°n',meaning:'n√∫i'}],'‰ºö':[{radical:'‰∫∫',name:'Nh√¢n',meaning:'ng∆∞·ªùi'},{radical:'‰∫ë',name:'V√¢n',meaning:'m√¢y'}],'ÂèØ':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'},{radical:'‰∏Å',name:'ƒêinh',meaning:'can ƒêinh'}],'‰πü':[{radical:'‰πü',name:'D√£',meaning:'c≈©ng'}],'‰Ω†':[{radical:'‰∫ª',name:'Nh√¢n ƒë·ª©ng',meaning:'ng∆∞·ªùi'},{radical:'Â∞î',name:'Nhƒ©',meaning:'m√†y'}],'ÂØπ':[{radical:'Âèà',name:'H·ª±u',meaning:'l·∫°i'},{radical:'ÂØ∏',name:'Th·ªën',meaning:'t·∫•c'}],'Áîü':[{radical:'Áîü',name:'Sinh',meaning:'s·ªëng'}],'ËÉΩ':[{radical:'Êúà',name:'Nguy·ªát',meaning:'m·∫∑t trƒÉng'},{radical:'Âåï',name:'Ch·ªßy',meaning:'c√°i th√¨a'}],'ËÄå':[{radical:'ËÄå',name:'Nhi',meaning:'m√†'}],'Â≠ê':[{radical:'Â≠ê',name:'T·ª≠',meaning:'con'}],'ÈÇ£':[{radical:'ÈÇë',name:'·∫§p',meaning:'v√πng ƒë·∫•t'},{radical:'ÂÜâ',name:'Nhi·ªÖm',meaning:'y·∫øu ·ªõt'}],'Âæó':[{radical:'ÂΩ≥',name:'X√≠ch',meaning:'b∆∞·ªõc ch√¢n tr√°i'},{radical:'Êó•',name:'Nh·∫≠t',meaning:'m·∫∑t tr·ªùi'}],'‰∫é':[{radical:'‰∫å',name:'Nh·ªã',meaning:'s·ªë hai'}],'ÁùÄ':[{radical:'Áæä',name:'D∆∞∆°ng',meaning:'con d√™'},{radical:'ÁõÆ',name:'M·ª•c',meaning:'m·∫Øt'}],'‰∏ã':[{radical:'Âçú',name:'B·ªëc',meaning:'xem b√≥i'}],'Áªô':[{radical:'Á∫ü',name:'M·ªãch',meaning:'s·ª£i t∆°'},{radical:'Âêà',name:'H·ª£p',meaning:'h·ª£p l·∫°i'}],'Á≠â':[{radical:'Á´π',name:'Tr√∫c',meaning:'tre'},{radical:'ÂØ∫',name:'T·ª±',meaning:'ng√¥i ch√πa'}],'Âéª':[{radical:'Âúü',name:'Th·ªï',meaning:'ƒë·∫•t'}],'Â•Ω':[{radical:'Â•≥',name:'N·ªØ',meaning:'ph·ª• n·ªØ'},{radical:'Â≠ê',name:'T·ª≠',meaning:'con'}],'Ëøá':[{radical:'Ëæ∂',name:'S∆∞·ªõc',meaning:'ƒëi'}],'Âêé':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Â∞è':[{radical:'Â∞è',name:'Ti·ªÉu',meaning:'nh·ªè'}],'‰πà':[{radical:'Âé∂',name:'T∆∞',meaning:'ri√™ng t∆∞'}],'ÂøÉ':[{radical:'ÂøÉ',name:'T√¢m',meaning:'tr√°i tim'}],'Â§ö':[{radical:'Â§ï',name:'T·ªãch',meaning:'ƒë√™m t·ªëi'}],'Â§©':[{radical:'Â§ß',name:'ƒê·∫°i',meaning:'to l·ªõn'}],'T√™n':[{radical:'Â§ï',name:'T·ªãch',meaning:'ƒë√™m t·ªëi'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'T√°c':[{radical:'‰∫ª',name:'Nh√¢n ƒë·ª©ng',meaning:'ng∆∞·ªùi'},{radical:'‰πç',name:'S·∫°',meaning:'b·ªóng nhi√™n'}],'√ù':[{radical:'Èü≥',name:'√Çm',meaning:'√¢m thanh'},{radical:'ÂøÉ',name:'T√¢m',meaning:'tr√°i tim'}],'Th·∫≠p':[{radical:'ÂçÅ',name:'Th·∫≠p',meaning:'s·ªë m∆∞·ªùi'}],'V·∫•n':[{radical:'Èó®',name:'M√¥n',meaning:'c·ª≠a'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'NƒÉm':[{radical:'Âçà',name:'Ng·ªç',meaning:'gi·ªØa tr∆∞a'}],'An':[{radical:'ÂÆÄ',name:'Mi√™n',meaning:'m√°i nh√†'},{radical:'Â•≥',name:'N·ªØ',meaning:'ph·ª• n·ªØ'}],'L√Ω':[{radical:'Êú®',name:'M·ªôc',meaning:'c√¢y'},{radical:'Â≠ê',name:'T·ª≠',meaning:'con'}],'Hi·ªán':[{radical:'Áéâ',name:'Ng·ªçc',meaning:'ng·ªçc'}],'Ph√°t':[{radical:'Áô∂',name:'B√°t',meaning:'g·∫°t ra'}],'C·∫£m':[{radical:'Âí∏',name:'H√†m',meaning:'kh·∫Øp'},{radical:'ÂøÉ',name:'T√¢m',meaning:'tr√°i tim'}],'T√¨m':[{radical:'Êâã',name:'Th·ªß',meaning:'tay'}],'ƒê·ªìng':[{radical:'ÂÜÇ',name:'Quynh',meaning:'bi√™n gi·ªõi'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Ki·∫øn':[{radical:'ËßÅ',name:'Ki·∫øn',meaning:'th·∫•y'}],'H√†nh':[{radical:'Ë°å',name:'H√†nh',meaning:'ƒëi'}],'B√™n ngo√†i':[{radical:'Â§ï',name:'T·ªãch',meaning:'ƒë√™m t·ªëi'},{radical:'Âçú',name:'B·ªëc',meaning:'xem b√≥i'}],'Tr∆∞·ªõc':[{radical:'ÂàÇ',name:'ƒêao',meaning:'con dao'}],'L·ª±c l∆∞·ª£ng':[{radical:'Âäõ',name:'L·ª±c',meaning:'s·ª©c m·∫°nh'}],'Nh√¨n':[{radical:'ÁõÆ',name:'M·ª•c',meaning:'m·∫Øt'}],'M·∫∑t':[{radical:'Èù¢',name:'Di·ªán',meaning:'m·∫∑t'}],'D·ª•ng c·ª•':[{radical:'Áî®',name:'D·ª•ng',meaning:'d√πng'}],'H·ªçc':[{radical:'Â≠ê',name:'T·ª≠',meaning:'con'}],'S·ª± th·∫≠t':[{radical:'Âåï',name:'Ch·ªßy',meaning:'c√°i th√¨a'}],'ƒê∆∞·ªùng':[{radical:'ÂΩ≥',name:'X√≠ch',meaning:'b∆∞·ªõc ch√¢n tr√°i'}],'Kh√≠':[{radical:'Ê∞î',name:'Kh√≠',meaning:'kh√¥ng kh√≠'}],'ƒêi·ªÅu':[{radical:'ËÆ†',name:'Ng√¥n',meaning:'l·ªùi n√≥i'}],'C√¥ng vi·ªác':[{radical:'Â∑•',name:'C√¥ng',meaning:'c√¥ng vi·ªác'}],'Tr·ªü th√†nh':[{radical:'Êàà',name:'Qua',meaning:'c√°i m√°c'}],'Nh√†':[{radical:'Ë±ï',name:'Th·ªâ',meaning:'con l·ª£n'}],'Ch·ªâ':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Nh∆∞':[{radical:'Â•≥',name:'N·ªØ',meaning:'ph·ª• n·ªØ'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Bi·∫øt':[{radical:'Áü¢',name:'Th·ªâ',meaning:'m≈©i t√™n'},{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'T·ªïng':[{radical:'Á≥∏',name:'M·ªãch',meaning:'s·ª£i t∆°'},{radical:'ÂøÉ',name:'T√¢m',meaning:'tr√°i tim'}],'Gi·ªØa':[{radical:'Êó•',name:'Nh·∫≠t',meaning:'m·∫∑t tr·ªùi'}],'Xem':[{radical:'ÁõÆ',name:'M·ª•c',meaning:'m·∫Øt'}],'Kh√¥ng c√≥':[{radical:'Êúà',name:'Nguy·ªát',meaning:'m·∫∑t trƒÉng'}],'T·ª´':[{radical:'Ëá™',name:'T·ª±',meaning:'t·ª± m√¨nh'}],'Tay':[{radical:'Êâã',name:'Th·ªß',meaning:'tay'}],'ƒê·∫ßu':[{radical:'È¶ñ',name:'Th·ªß',meaning:'ƒë·∫ßu'}],'Ch·ªß ƒë·ªÅ':[{radical:'È°µ',name:'Hi·ªát',meaning:'trang gi·∫•y'}],'Ph·∫£i':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'Tr√°i':[{radical:'Â∑•',name:'C√¥ng',meaning:'c√¥ng vi·ªác'}],'Cao':[{radical:'È´ò',name:'Cao',meaning:'cao'}],'ƒê·ªông':[{radical:'Âäõ',name:'L·ª±c',meaning:'s·ª©c m·∫°nh'}],'So s√°nh':[{radical:'ÊØî',name:'T·ª∑',meaning:'so s√°nh'}],'V·ªõi':[{radical:'Ëæ∂',name:'S∆∞·ªõc',meaning:'ƒëi'}],'M·ªü':[{radical:'Èó®',name:'M√¥n',meaning:'c·ª≠a'}],'Th√¢n':[{radical:'Ë∫´',name:'Th√¢n',meaning:'th√¢n th·ªÉ'}],'G·ªçi':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'M·ªõi':[{radical:'Êñ§',name:'C√¢n',name:'c√°i r√¨u'}],'Gia ƒë√¨nh':[{radical:'ÂÆÄ',name:'Mi√™n',meaning:'m√°i nh√†'}],'Th√†nh':[{radical:'Êàä',name:'M·∫≠u',meaning:'can M·∫≠u'},{radical:'‰∏Å',name:'ƒêinh',meaning:'can ƒêinh'}],'S√°ch':[{radical:'ËÅø',name:'Du·∫≠t',meaning:'c√°i b√∫t'}],'Th√≠ch':[{radical:'Ê¨†',name:'Khi·∫øm',meaning:'thi·∫øu'}],'Th·ª© hai':[{radical:'Ê¨†',name:'Khi·∫øm',meaning:'thi·∫øu'}],'C∆° th·ªÉ':[{radical:'È™®',name:'C·ªët',meaning:'x∆∞∆°ng'}],'√çt':[{radical:'Â∞è',name:'Ti·ªÉu',meaning:'nh·ªè'}],'ƒêi·ªán':[{radical:'Èõ®',name:'V≈©',meaning:'m∆∞a'},{radical:'Áî≥',name:'Th√¢n',meaning:'th·ªânh c·∫ßu'}],'H√¨nh ·∫£nh':[{radical:'ÂΩ°',name:'Sam',meaning:'l√¥ng'}],'M·∫∑c d√π':[{radical:'Âè£',name:'Kh·∫©u',meaning:'mi·ªáng'}],'H√†ng':[{radical:'ÂΩ≥',name:'X√≠ch',meaning:'b∆∞·ªõc ch√¢n tr√°i'}],'ƒêen':[{radical:'Èªë',name:'H·∫Øc',meaning:'m√†u ƒëen'}],'Tr·∫Øng':[{radical:'ÁôΩ',name:'B·∫°ch',meaning:'tr·∫Øng'}],'ƒê·ªè':[{radical:'Ëµ§',name:'X√≠ch',meaning:'m√†u ƒë·ªè'}],'Xanh':[{radical:'Èùí',name:'Thanh',meaning:'m√†u xanh'}],'V√†ng':[{radical:'ÈªÑ',name:'Ho√†ng',meaning:'m√†u v√†ng'}]
    };

    const strokeOrderModal = document.getElementById('stroke-order-modal');
    const strokeOrderContainer = document.getElementById('stroke-order-container');
    const strokeOrderCloseBtn = document.getElementById('stroke-order-close-btn');
    const strokeOrderAnimateAllBtn = document.getElementById('stroke-order-animate-all-btn');
    let hanziWriters = [];

    // Phi√™n b·∫£n cu·ªëi c√πng, ch·ªâ s·ª≠ d·ª•ng d·ªØ li·ªáu offline, kh√¥ng g·ªçi API
    function startMultiPractice(text) {
        const characters = text.split('').filter(char => /[\u4e00-\u9fa5]/.test(char));
        if (characters.length === 0) return;

        strokeOrderContainer.innerHTML = '';
        hanziWriters = [];
        strokeOrderModal.style.display = 'flex';

        characters.forEach((character, index) => {
            const wrapperDiv = document.createElement('div');
            wrapperDiv.className = 'character-wrapper';
            
            const charDiv = document.createElement('div');
            charDiv.id = `char-target-${index}`;
            charDiv.className = 'char-writer-box';
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'radical-info';

            wrapperDiv.appendChild(charDiv);
            wrapperDiv.appendChild(infoDiv);

            // Ch·ªâ t√¨m trong d·ªØ li·ªáu c√≥ s·∫µn
            const charData = localRadicalData[character];
            if (charData) {
                let infoHtml = '<div><b>Th√†nh ph·∫ßn:</b></div>';
                charData.forEach(r => {
                    infoHtml += `<div>- ${r.radical} (${r.name}): ${r.meaning}</div>`;
                });
                infoDiv.innerHTML = infoHtml;
            } else {
                // N·∫øu kh√¥ng c√≥, hi·ªÉn th·ªã th√¥ng b√°o
                infoDiv.innerHTML = '<em>Kh√¥ng c√≥ d·ªØ li·ªáu cho ch·ªØ n√†y.</em>';
            }
            
            strokeOrderContainer.appendChild(wrapperDiv);

            const writer = HanziWriter.create(charDiv.id, character, {
                width: 150, height: 150, padding: 5, showOutline: true,
                showCharacter: false, strokeAnimationSpeed: 1, delayBetweenStrokes: 200,
            });
            hanziWriters.push(writer);
        });

        hanziWriters.forEach(writer => writer.quiz());
    }

    function hidePractice() {
        strokeOrderModal.style.display = 'none';
        strokeOrderContainer.innerHTML = '';
        hanziWriters = [];
    }
    
    strokeOrderCloseBtn.addEventListener('click', hidePractice);
    strokeOrderAnimateAllBtn.addEventListener('click', () => {
        hanziWriters.forEach(writer => writer.animateCharacter());
    });

    document.addEventListener('keydown', function(event) {
        if (event.altKey && (event.key === 'P' || event.key === 'p')) {
            if (strokeOrderModal.style.display !== 'flex') {
                const selection = window.getSelection();
                const selectedText = selection.toString().trim();
                if (selectedText) {
                    event.preventDefault();
                    startMultiPractice(selectedText);
                }
            }
        }
        
        if (event.key === 'Escape' && strokeOrderModal.style.display === 'flex') {
            hidePractice();
        }
    });

    // =================================================================
    // =================== INITIALIZATION ==============================
    // =================================================================
    window.onload = () => {
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = initializeVoices;
        }
        initializeVoices();
        document.getElementById("questions-container").innerHTML = '';
        questionCount = 0;
        addNewQuestion();
    };
</script>
</body>
</html>
